/**
 * @namespace bs
 * @brief BashSpark main namespace
 */

/**
 * @mainpage
 *
 * @brief BashSpark - A powerful C++ library for custom command execution. <br>
 *
 *
 * BashSpark is a command-line tool inspired by the Bash shell that allows users to execute custom commands
 * seamlessly and flexibly. It supports various command types and functionalities tailored for enhanced usability.
 *
 * @section key_features Key Features
 * - **Bash Inspiration**: While it draws inspiration from the Bash shell, it introduces unique features
 *   and behaviors to enhance usability.
 * - **Custom Command Execution**: Users can define and execute their own commands, enabling flexible
 *   scripting and automation.
 * - **Rich Functionality**: Accommodates diverse user needs through various command types and execution options.
 *
 * @section syntax_support Bash-style Syntax Support
 * BashSpark supports a variety of Bash-style syntaxes including:
 * - `${VARIABLE_NAME}`
 * - `${!VARIABLE_NAME}`
 * - `$(command)`
 * - `function function_name {...}`
 *
 * Note: Does not recognize semicolons or newlines generated by expansion.
 * Example: `$cmd` where `cmd="echo -n 1; echo -n 2"` outputs `1; echo -n 2`, not `12`.
 *
 * @section unique_capabilities Unique Capabilities
 * - Interprets escaped characters (e.g., `\n` for newline, `\t` for tab).
 * - Supports Unicode code points:
 *   - `\x` for ASCII
 *   - `\u` for UTF-16
 *   - `\U` for UTF-32
 * - Returns `shell_status::SHELL_ERROR_BAD_ENCODING` for invalid code points.
 *
 * @section different_behaviour Different Behavior from Bash
 * - No requirement for spaces around '(', '[', '{', '}', ']' and ')'.
 * - Both `(` and `[` are always interpreted, e.g., "echo }" works while "echo \\}" works in both.
 * - Supports empty commands with valid syntax like ";;;".
 * - Does not support improved test syntax `[[...]]`.
 * - Normal tests support `||`, `&&` and parentheses `(...)`.
 * - Arithmetic using `(())` is not supported; use the `math` command instead.
 * - Variable assignments using `variable=value` are not supported; use `setenv` and `setvar` commands.
 * - Function definition syntax `function_name(){...}` is not supported; use `fcall function_name <args>`.
 *
 * @section command_management Command Management
 * Commands are instantiated from the `bs::command` class and managed within the shell to ensure
 * safe and reliable command execution by preventing security holes and handling errors gracefully.
 *
 * @section shell_depth Shell Depth
 * The parser has a limit for depth set by `std::size_t bs::shell::MAX_DEPTH`, defaulting to 16.
 * Users can modify this value and rebuild the project if necessary. The following conditions increase depth:
 * - Parsing subblocks like "(...)" and "{...}"
 * - Parsing subcommands like "$(...)"
 * - Command eval (new shell starts a new depth).
 * - Keywords like "if", "elif", "for", "while", "until".
 *
 * Parsing variables `${...}`, tests `[...]`, and keywords like "then", "fi", "else", "do", "done"
 * do not increase depth.
 *
 * @section known_issues Known Issues
 * Current implementation attempts to prevent SIGSEGV. The shell execution does not throw exceptions
 * except for `std::bad_alloc` or exceptions from provided streams.
 * All errors listed on `bs::shell_status` are notified through `stderr` with the last command error code,
 * including syntax errors and depth limit errors.
 *
 * Other limitations:
 * - Shell arguments are restricted to 19 digits due to `std::uint64_t` range.
 *
 * @section edoc Other documentation
 * - @ref license
 * - @ref cmake
 * - @ref install
 * - @ref shell_usage
 * - @ref api_usage
 */

/**
 * @page license License
 *
 * This file is part of BashSpark.
 *
 * Copyright (C) 2025 Dante Doménech Martínez
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see [https://www.gnu.org/licenses/](https://www.gnu.org/licenses/)
 *
 */

/**
 * @page cmake CMake Integration
 *
 * This documentation provides step-by-step instructions for integrating, building, and installing
 * the BashSpark library using CMake.
 *
 * @section cmakei Using CMake for Integration
 *
 * To utilize this project in your own, integrate it via CMake by adding the following lines
 * to your `CMakeLists.txt` file:
 *
 * ```cmake
 * # Include FetchContent
 * include(FetchContent)
 *
 * # Fetch the repository
 * FetchContent_Declare(
 *         bashspark
 *         GIT_REPOSITORY https://github.com/dante19031999/bashspark.git
 *         GIT_TAG master
 * )
 * FetchContent_MakeAvailable(bashspark)
 *
 * # Define your library
 * add_library(foo ...)
 *
 * # Link your library with BashSpark
 * target_link_libraries(foo PRIVATE BashSpark::BashSpark)
 * ```
 *
 * @subsection cmake_alias Available Alias Options
 *
 * You can choose from several aliases depending on your needs:
 * - `BashSpark::ABashSpark`: static library.
 * - `BashSpark::FBashSpark`: static library with position-independent code.
 * - `BashSpark::SBashSpark`: dynamic library.
 * - `BashSpark::BashSpark`: default dynamic library.
 *
 * @subsection cmake_doc Generating the Documentation
 *
 * This project includes comprehensive documentation detailing its functionality.
 * To generate the documentation, follow these steps:
 * 1. The CMake configuration file includes a dedicated "doc" target.
 * 2. Executing this target will generate the Doxygen documentation in `${PROJECT_DIR}/docs`.
 * 3. Access the documentation at `${PROJECT_DIR}/docs/html/index.html`.
 *
 * The library [Doxygen Awesome](https://github.com/jothepro/doxygen-awesome-css) is used to
 * enhance documentation aesthetics.
 *
 */

/**
 * @page install Library installation
 *
 * The CMake file defines the following targets:
 * - `doc`: Generates documentation.
 * - `deb`: Generate `.deb` file of the library.
 * - `rpm`: Generate `.rpm` file of the library (currently unavailable).
 * - `headers`: Generates a zip file containing the library headers.
 * - `abashspark`: Generates a static library.
 * - `fbashspark`: Generates a static library with position-independent code.
 * - `sbashspark`: Generates a dynamic library.
 * - `tbashspark`: Generates the test executable.
 *
 * Exposed targets include:
 * - `BashSpark::ABashSpark`: static library.
 * - `BashSpark::FBashSpark`: static library with position-independent code.
 * - `BashSpark::SBashSpark`: dynamic library.
 * - `BashSpark::BashSpark`: default dynamic library.
 * - Property `BASH_SPARK_HEADER_DIR` with the include path.
 *
 * @section install_steps Installation Steps
 *
 * The installation process consists of the following steps:
 * 1. Configure CMake.
 * 2. Unpack the headers.
 * 3. Build the library.
 * 4. Copy the library.
 *
 * @subsection config_cmake Configure CMake
 *
 * Set the project directory with:
 * ```bash
 * BASH_SPARK="$(realpath .)"
 * ```
 * Then configure CMake:
 * ```bash
 * mkdir -p ${BASH_SPARK}/cmake-build && cd ${BASH_SPARK}/cmake-build && cmake ..
 * ```
 *
 * @subsection unpak_headers Unpacking the Headers
 *
 * On POSIX systems, the library headers are stored at `/usr/include`.
 * Execute the following commands:
 * ```bash
 * cd ${BASH_SPARK}/cmake-build && make headers
 * tar -xzf ${BASH_SPARK}/build/BashSpark.tar.gz -C ${BASH_SPARK}/build --strip-components=1 "./BashSpark"
 * sudo mv ${BASH_SPARK}/build/BashSpark /usr/include/BashSpark
 * ```
 * **Windows users**: Extract the file `${BASH_SPARK}/build/BashSpark.tar.gz` in the appropriate location.
 *
 * @subsection build_lib Building the Library
 *
 * Choose a library version to build:
 * - `abashspark`: Static library.
 * - `fbashspark`: Static library with position-independent code.
 * - `sbashspark`: Dynamic library.
 * - If you are not sure use the dynamic library.
 *
 * Execute the appropriate command:
 * ```bash
 * cd ${BASH_SPARK}/cmake-build && make <library_target>
 * ```
 *
 * ### Copying the Library
 *
 * On POSIX systems, copy the library to `/usr/lib`:
 * ```bash
 * sudo mkdir -p /usr/lib/BashSpark
 * ```

 * Then move the libraries:
 * ```bash
 * sudo mv ${BASH_SPARK}/build/libabashspark.a /usr/lib/BashSpark/libabashspark.a
 * sudo mv ${BASH_SPARK}/build/libfbashspark.a /usr/lib/BashSpark/libfbashspark.a
 * sudo mv ${BASH_SPARK}/build/libsbashspark.so /usr/lib/BashSpark/libsbashspark.so
 * ```
 *
 * After these steps, the BashSpark library will be properly integrated into your system.
 *
 * ## Additional Notes
 *
 * If the command `debuild` is missing, install the necessary tools with:
 * ```bash
 * sudo apt install devscripts
 * ```
 *
 * ### Install CMake
 *
 * Use the following commands based on your Linux distribution to install CMake:
 *
 * | Linux Distribution | Command                                       |
 * |--------------------|-----------------------------------------------|
 * | **Debian-based**   | `sudo apt install -y cmake`                   |
 * | **Red Hat-based**  | `sudo yum install -y cmake`                   |
 * | **Fedora**         | `sudo dnf install -y cmake`                   |
 * | **Arch Linux**     | `sudo pacman -S --noconfirm cmake`            |
 * | **Windows**        | [Download CMake](https://cmake.org/download/) |
 * | **MAC OS X**       | `brew install cmake`                          |
 *
 */

/**
 * @page shell_usage SHELL Usage Explanation
 *
 * This section explains the syntax and usage of some special shell commands.
 *
 * @section builtin_commands Built-in commands
 *
 * This section explains the built-in commands.
 *
 * @subsection echo Command echo
 *
 * The `echo` command writes its parameters to **stdout** exactly as provided.
 * If the `-n` option is used as the first parameter, **no newline** is printed at the end of the output.
 *
 * Examples:
 *
 * | Command                  | Output           |
 * |--------------------------|------------------|
 * | `echo "Hello World!"`    | `Hello World!\n` |
 * | `echo -n "Hello World!"` | `Hello World!`   |
 *
 * @subsection getenv Command getenv
 *
 * The `getenv` command retrieves the value of an environment variable.
 * If the variable does not exist, it returns an empty string `""`.
 *
 * Requires one argument: a valid environment variable name (like those in Bash).
 *
 * | Error Code                                                       | Meaning                             |
 * |------------------------------------------------------------------|-------------------------------------|
 * | `bs::shell_status::SHELL_CMD_ERROR_GETENV_PARAM_NUMBER`          | Wrong number of parameters provided |
 * | `bs::shell_status::SHELL_CMD_ERROR_GETENV_VARIABLE_NAME_INVALID` | Provided variable name is invalid   |
 *
 * Example: `getenv USER`
 *
 * @subsection setenv Command setenv
 *
 * The `setenv` command sets the value of an environment variable or creates it if it does not exist.
 * Requires two arguments: a valid environment variable name (like those in Bash) and a value.
 *
 * | Error Code                                                       | Meaning                             |
 * |------------------------------------------------------------------|-------------------------------------|
 * | `bs::shell_status::SHELL_CMD_ERROR_SETENV_PARAM_NUMBER`          | Wrong number of parameters provided |
 * | `bs::shell_status::SHELL_CMD_ERROR_SETENV_VARIABLE_NAME_INVALID` | Provided variable name is invalid   |
 *
 * Example:
 *
 * `setenv SHELL "BashSpark"`
 *
 * @subsection getvar Command getvar
 *
 * The `getvar` command retrieves the value of a local variable.
 * If the variable does not exist, it returns an empty string `""`.
 *
 * Requires one argument: a valid variable name (like those in Bash).
 *
 * | Error Code                                                       | Meaning                             |
 * |------------------------------------------------------------------|-------------------------------------|
 * | `bs::shell_status::SHELL_CMD_ERROR_GETVAR_PARAM_NUMBER`          | Wrong number of parameters provided |
 * | `bs::shell_status::SHELL_CMD_ERROR_GETVAR_VARIABLE_NAME_INVALID` | Provided variable name is invalid   |
 *
 * Example:
 *
 * `getvar variable`
 *
 * @subsection setvar Command setvar
 *
 * The `setvar` command sets the value of a local variable or creates it if it does not exist.
 * Requires two arguments: a valid variable name (like those in Bash) and a value.
 *
 * | Error Code                                                       | Meaning                             |
 * |------------------------------------------------------------------|-------------------------------------|
 * | `bs::shell_status::SHELL_CMD_ERROR_SETVAR_PARAM_NUMBER`          | Wrong number of parameters provided |
 * | `bs::shell_status::SHELL_CMD_ERROR_SETVAR_VARIABLE_NAME_INVALID` | Provided variable name is invalid   |
 *
 * Example: `setvar variable "value"`
 *
 * @subsection seq Command seq
 *
 * The `seq` command creates a sequence of integers.
 * The sequence can be **growing** or **shrinking**.
 *
 * Takes 3 integer parameters: `start`, `step`, `end`.
 *
 * - The `step` parameter is optional and defaults to `1` or `-1` depending on the sequence direction.
 * - The sequence must extend over a **closed set of values** (logic error if violated).
 * - Integer parameters are limited to **18 digits** (64-bit signed integers).
 *
 * | Error Code                                                 | Meaning                                      |
 * |------------------------------------------------------------|----------------------------------------------|
 * | `bs::shell_status::SHELL_CMD_ERROR_SEQ_PARAM_NUMBER`       | Wrong number of parameters                   |
 * | `bs::shell_status::SHELL_CMD_ERROR_SEQ_INVALID_INT_FORMAT` | Parameter is not a valid integer             |
 * | `bs::shell_status::SHELL_CMD_ERROR_SEQ_INT_OUT_OF_BOUNDS`  | Parameter exceeds 64-bit integer limits      |
 * | `bs::shell_status::SHELL_CMD_ERROR_SEQ_ITERATION_LOGIC`    | Step and range do not allow a valid sequence |
 *
 * Examples:
 *
 * | Command              | Output      |
 * |----------------------|-------------|
 * | `seq 1 5`            | `1 2 3 4 5` |
 * | `seq 1 2 5`          | `1 3 5`     |
 * | `seq 5 -2 1`         | `5 3 1`     |
 * | `seq 5 1`            | `5 4 3 2 1` |
 * | `echo -n $(seq 1 5)` | `1 2 3 4 5` |
 *
 * @subsection math Command math
 *
 * The `math` command performs simple integer arithmetic.
 * It takes mathematical expressions as parameters, broken down into independent tokens.
 *
 * Supports:
 *
 * - **Operators:** `+`, `-`, `*`, `/`, `^`, `**`, `×`, `÷`
 * - **Integer numbers** within the range of 64-bit signed integers
 * - **Parentheses:** `(` `)` (including nested parentheses)
 * - **Negative powers partially:** `{ x != 0 } ^ { y < 0 } = 0`
 * - **Functions:**
 *     - `factorial(x)`
 *     - `sum(variable; start; end; step; expression)` — sums `expression` over the sequence of `variable`, e.g.,
 *       `count = sum(x;1;1;100;1)`
 *     - `product(variable; start; end; step; expression)` — multiplies `expression` over the sequence of `variable`, e.g.,
 *       `factorial = product(x;1;1;100;x)`
 *     - Note: a variable inside `sum`/`product` hides the same variable from the outside scope
 *     - Variable names must be valid shell variable names
 *
 * Possible errors:
 *
 * | Error Code                                                     | Meaning                                   |
 * |----------------------------------------------------------------|-------------------------------------------|
 * | `bs::shell_status::SHELL_CMD_ERROR_MATH_NOT_AN_INTEGER`        | Value is not an integer                   |
 * | `bs::shell_status::SHELL_CMD_ERROR_MATH_OVERFLOW`              | Integer overflow                          |
 * | `bs::shell_status::SHELL_CMD_ERROR_MATH_UNDERFLOW`             | Integer underflow                         |
 * | `bs::shell_status::SHELL_CMD_ERROR_MATH_DIV_BY_ZERO`           | Division by zero                          |
 * | `bs::shell_status::SHELL_CMD_ERROR_MATH_POW_0_EXP_0`           | 0^0 power is undefined                    |
 * | `bs::shell_status::SHELL_CMD_ERROR_MATH_FACTORIAL_NEGATIVE`    | Factorial of negative number              |
 * | `bs::shell_status::SHELL_CMD_ERROR_MATH_MALFORMED_EXPRESSION`  | Expression is malformed                   |
 * | `bs::shell_status::SHELL_CMD_ERROR_MATH_MAX_DEPTH_REACHED`     | Maximum recursion depth reached (512)     |
 * | `bs::shell_status::SHELL_CMD_ERROR_MATH_INVALID_VARIABLE_NAME` | Invalid variable name in function         |
 * | `bs::shell_status::SHELL_CMD_ERROR_MATH_SEQ_ITERATION_LOGIC`   | Sequence logic error in sequence function |
 *
 * Examples:
 *
 * | Command                                                                             | Output        |
 * |-------------------------------------------------------------------------------------|---------------|
 * | `math + 1`                                                                          | `1`           |
 * | `math - 1`                                                                          | `-1`          |
 * | `math +1`                                                                           | `1`           |
 * | `math -1`                                                                           | `-1`          |
 * | `math 3 + 4`                                                                        | `7`           |
 * | `math 3 * 4`                                                                        | `12`          |
 * | `math 12 / 4`                                                                       | `3`           |
 * | `math 12 % 5`                                                                       | `2`           |
 * | `math 2 ^ 3`                                                                        | `8`           |
 * | `math 2 ** 3`                                                                       | `8`           |
 * | `math 2 ** - 3`                                                                     | `0`           |
 * | `math 2 + 2 * 2 + 2 ^ 2 + 2 * 2 + 2`                                                | `16`          |
 * | `math 42 ^ 0 + 1 ^ 42 + 0 ^ 42`                                                     | `2`           |
 * | `math \( 2 + 2 \) * \( 2 + 2 \) ^ \( 2 + 2 \) * \( 2 + 2 \)`                        | `4096`        |
 * | `math $(echo "( 2 + 2 ) * ( 2 + 2 ) ^ ( 2 + 2 ) * ( 2 + 2 )")`                      | `4096`        |
 * | `math \( \( 2 + 2 \) * \( 2 + 2 \) \) ^ \( \( 1 + 2 \) * \( 1 + 2 \) \)`            | `68719476736` |
 * | `math factorial \( 5 \)`                                                            | `120`         |
 * | `math product \( x , 1 , 1 , 5 , x \)`                                              | `120`         |
 * | `math sum \( x , 1 , 1 , 5 , x \)`                                                  | `15`          |
 * | ``echo $( math sign \( - 42 \) ) $( math sign \( 0 \) ) $( math sign \( + 42 \) )`` | `-1 0 1`      |
 * | `math abs \( - 42 \)`                                                               | `42`          |
 * | `math abs \( + 42 \)`                                                               | `42`          |
 * | `setvar i $(math i + 1)`                                                            | ``            |
 *
 * @subsection test Command test
 *
 * The `test` command performs simple tests.
 * It takes test expressions as parameters, broken down into independent tokens.
 *
 * Capabilities:
 *
 * - Operators or: -o, ||
 * - Operators and: -a, &&
 * - Comparison operators: ==, -eq, >, -gt, <, -lt, >=, -ge, <=, -le
 *   Note that comparison operators will apply numeric comparison if both arguments are
 *   numbers or <=> on std::string if they aren't.
 * - Operator =~: use a =~ b, checks if a matches b. Uses C++ regex, not bash regex.
 * - Parentheses: ( ) (and nested parentheses).
 *
 * Possible status codes outputs:
 *
 * | Status                                                        | Description                   |
 * |---------------------------------------------------------------|-------------------------------|
 * | `bs::shell_status::SHELL_SUCCESS`                             | Test passed                   |
 * | `bs::shell_status::SHELL_CMD_TEST_FALSE`                      | Test failed                   |
 * | `bs::shell_status::SHELL_CMD_ERROR_TEST_UNCLOSED_PARENTHESIS` | Opened parenthesis not closed |
 * | `bs::shell_status::SHELL_CMD_ERROR_TEST_MALFORMED_EXPRESSION` | Malformed expression          |
 * | `bs::shell_status::SHELL_CMD_ERROR_TEST_MALFORMED_REGEX`      | Malformed regex               |
 *
 * Examples:
 *
 * | Command                                                 | Meaning                                  | Result    |
 * |---------------------------------------------------------|------------------------------------------|-----------|
 * | `test -z ""`                                            | Is the string empty?                     | **true**  |
 * | `test -n "d"`                                           | Is the string non-empty?                 | **true**  |
 * | `test 7 -eq 0007`                                       | Numeric equality (leading zeros allowed) | **true**  |
 * | `test 7 != 42`                                          | Numeric inequality                       | **true**  |
 * | `test abc != 42`                                        | String inequality                        | **true**  |
 * | `test 7 -gt 6`                                          | Numeric greater-than                     | **true**  |
 * | `test b > a`                                            | Lexicographic greater-than               | **true**  |
 * | `test 6 -le 7`                                          | Numeric ≤ comparison                     | **true**  |
 * | ``test 'hello' =~ '^h.*o$'``                            | Regex match                              | **true**  |
 * | ``test 'abc' =~ '^[0-9]+$'``                            | Regex check: digits only?                | **false** |
 * | ``test 'test@example.com' =~ '^[^@]+@[^@]+\\\\.[^@]+$'``| Email-like pattern                       | **true**  |
 *
 * @subsection fcall Command fcall
 *
 * The `fcall` command calls functions.
 * The first parameter is the function name.
 * The other parameters are the function parameters.
 *
 * Example:
 *
 * ```bash
 * function echon {
 *     echo -n $@
 * }
 *
 * fcall echon Hello World!
 * ```
 *
 * Output: `Hello World!`
 *
 * @section script Script examples
 *
 * This section displays some simple example scripts. Allows to better grasp the shell syntax.
 *
 * @subsection helloworld Hello world
 *
 * ```bash
 * echo -n 'Hello, World!'"
 * ```
 *
 * Output: `Hello, World!\n`
 *
 * @subsection whileloop While loop
 *
 * ```bash
 * setvar count 1
 * while [ $count <= 5 ];
 * do
 *     echo \"Count: $count\"; setvar count $(math $count + 1);
 * done
 * ```
 *
 * Output:
 *
 * ```text
 * Count: 1
 * Count: 2
 * Count: 3
 * Count: 4
 * Count: 5
 * ```
 *
 * @subsection untilloop Until loop
 *
 * ```bash
 * setvar count 1
 * until [ $count > 5 ];
 * do
 *     echo \"Count: $count\"; setvar count $(math $count + 1);
 * done
 * ```
 *
 * Output:
 *
 * ```text
 * Count: 1
 * Count: 2
 * Count: 3
 * Count: 4
 * Count: 5
 * ```
 *
 * @subsection forloop Loop for
 *
 * ```bash
 * for i in $(seq 1 5);
 * do
 *     echo -n $i;
 * done
 * ```
 *
 * Output: `12345`
 *
 * @subsection function_greet Function
 *
 * ```bash
 * function greet {
 *     echo \"Ave $1\"
 * }
 *
 * fcall greet Cesar
 * ```
 *
 * Output: `Ave Cesar\n`
 *
 * @subsection function_count_param Count function arguments
 *
 * ```bash
 * function count_args {
 *     echo -n $#
 * }
 *
 * fcall count_args $(seq 1 5)
 * ```
 *
 * Output: `5`
 *
 * @subsection function_ifelse Function with if-else block
 *
 * ```bash
 * function oddeven {
 *     if [ $(math $1 % 2) == 0 ];
 *     then
 *         echo \"$1 is even\"
 *     else
 *         echo \"$1 is odd\"
 *     fi
 * }
 *
 * fcall oddeven
 * ```
 *
 * Output:
 *
 * ```text
 * 42 is even
 * 11 is odd
 * ```
 *
 * @subsection function_args Function that displays it's arguments
 *
 * ```bash
 * function show_args {
 *     if [ $# > 1 ];
 *     then
 *         for i in $(seq 1 $#);
 *         do
 *             echo \"arg $i: \\u201C${!i}\\u201D\";
 *         done
 *     else
 *         echo 'No arguments';
 *     fi
 * }
 *
 * fcall show_args
 * fcall show_args $(seq 1 5)
 * ```
 *
 * Output:
 *
 * ```text
 * No arguments
 * arg 1: “1”
 * arg 2: “2”
 * arg 3: “3”
 * arg 4: “4”
 * arg 5: “5”
 * ```
 */

/**
 * @page api_usage API Usage explanation
 *
 * This section provides detailed instructions on how to utilize the BashSpark library effectively. It covers essential
 * operations such as creating a shell instance, initializing a shell session, executing commands, and developing custom
 * commands.
 *
 * By following these guidelines, developers can manage command execution securely and efficiently while avoiding common
 * pitfalls. The examples included showcase practical implementations, helping users to grasp each concept through hands-on
 * coding snippets. Whether you are new to the library or seeking to enhance your command structures, this section serves
 * as a comprehensive guide for operational success.
 *
 * @section create_shell Create a shell instance
 *
 * The first step to run commands is to create a shell. This class is named `bs::shell`.
 * This class manages the available commands.
 *
 * This command management method allow the programmer to strictly control the allowed
 * behaviors, preventing security holes. This enhances the safety and reliability
 * of command execution, ensuring that only authorized commands are executed
 * and that errors are handled gracefully.
 *
 * It is possible to obtain the default shell using method `std::unique_ptr<bs::shell> bs::shell::make_default_shell()`.
 * The
 * user may also use the default constructor `bs::shell()` to create a custom shell.
 *
 * The class shell session may have the following methods overridden to change behavior (such as internationalization):
 *
 * - `void shell::msg_error_command_not_found(shell_session &, const std::string &) const`: error message on command not
 *   found.
 * - `void shell::msg_error_syntax_error(const shell_session &, const shell_exception &) const`: error message on syntax
 *   error.
 *
 * Example on obtaining the default session:
 *
 * ```hpp
 * std::unique_ptr<bs::shell> pShell = bs::shell::make_default_shell();
 * ```
 *
 * Example on building the default session:
 *
 * ```hpp
 * std::unique_ptr<shell> shell::make_default_shell() {
 *     auto pShell = std::make_unique<shell>();
 *     pShell->set_command<command_echo>();
 *     pShell->set_command<command_eval>();
 *     pShell->set_command<command_getenv>();
 *     pShell->set_command<command_getvar>();
 *     pShell->set_command<command_setenv>();
 *     pShell->set_command<command_setvar>();
 *     pShell->set_command<command_seq>();
 *     pShell->set_command<command_test>();
 *     pShell->set_command<command_math>();
 *     pShell->set_command<command_fcall>();
 *     return pShell;
 * }
 * ```
 *
 * @section create_session Create a shell session
 *
 * In order to execute shell commands a shell session is needed. This class is named `bs::shell_session`.
 * The class `bs::shell_session` contains the streams (stdin, stdout, stderr), the environment variables, the function
 * arguments, the local variables, the last exit status code and the shell depth.
 * See the documentation on `bs::shell_session` for more details.
 *
 * A `bs::shell_session` is constructed as
 * `shell_session(const shell *pShell, std::istream &oStdIn, std::ostream &oStdOut, std::ostream &oStdErr)`.
 *
 * The class `bs::shell_session` may be extended in order to add custom information to the session.
 * If a custom command uses the custom session, on method
 * `bs::command::run(const std::span<const std::string> &, shell_session &) const`,
 * it will be necessary to use `auto pCustomSession = dynamic_cast<shell_session_custom*>(&oSession)` in order to acquire
 * it.
 *
 * Example of shell session directly linked to terminal:
 *
 * ```hpp
 * // Generate shell
 * std::unique_ptr<bs::shell> pShell = bs::shell::make_default_shell();
 * // Instantiare session
 * bs::shell_session oSession(
 *     pShell.get(), // Owning shell
 *     std::cin, // stdin
 *     std::cout, // stdout
 *     std::cerr // stderr
 * );
 * ```
 *
 * @section run_command Run a command
 *
 * Running a command requires instantiating the sell session and using the methods
 * `shell_status shell::run(std::istream &oCommand,shell_session &oSession);`,
 * `shell_status run(const std::string &sCommand, shell_session &oSession);` or
 * `shell_status run(const std::string_view &sCommand, shell_session &oSession);`.
 *
 * Example of hello world:
 *
 * ```hpp
 * bs::shell_status run_helloworld() {
 *     // Generate shell
 *     std::unique_ptr<bs::shell> pShell = bs::shell::make_default_shell();
 *     // Instantiare session
 *     bs::shell_session oSession(
 *         pShell.get(), // Owning shell
 *         std::cin, // stdin
 *         std::cout, // stdout
 *         std::cerr // stderr
 *     );
 *     // Run command
 *     return bs::shell::run("echo -n 'Hello world!'"sv, oSession);
 * }
 * ```
 *
 * @section create_command Create a custom command
 *
 * Creating a custom command requires implementing the `bs::command` interface.
 *
 * The custom command class has to override the method
 * `bs::command::run(const std::span<const std::string> &, shell_session &) const`.
 * On success, the `run` method must return `bs::shell_status::SHELL_SUCCESS`.
 * On failure, the `run` method must return `return bs::make_user_code(USER_ERROR_CODE)` (see \ref bs::make_user_code) where `USER_ERROR_CODE` is an
 * `unsigned int`.
 *
 * It is recommended to define supplementary functions to print the error messages.
 * Such functions would have a prototype like: `print_error(std::ostream& oStderr) const`.
 *
 * Use the function `bs::shell::set_command(std::unique_ptr<command> &&)` to add the custom commands.
 * The helper template `template<typename CommandT, typename... Args> void bs::shell::set_command(Args &&...)` may also be
 * useful.
 *
 * If the custom command uses a custom session, on method
 * `bs::command::run(const std::span<const std::string> &, shell_session &) const`,
 * it will be necessary to use `auto pCustomSession = dynamic_cast<shell_session_custom*>(&oSession)` in order to acquire
 * it.
 *
 * If the custom command calls subshells, to prevent SIGSEGV by stack overflow it is recommended
 * to check the shell depth. Custom commands should not modify this depth lightly.
 *
 * Example:
 *
 * \code{hpp}
 *  // @class command_helloworld
 *  // @brief Prints "Hellow world!" on stdout.
 *  // Syntax: helloworld
 * class command_helloworld : public bs::command {
 * public:
 *      // @brief Constructs the command
 *      // Instantiates bs::command with the command name
 *     command_helloworld()
 *         : bs::command("helloworld") {
 *     }
 *
 * public:
 *      // @brief Prints "Hellow world!" on stdout
 *      // If the argument number is different from 0 then msg_error_param_number is called.
 *      // @param vArgs Command arguments
 *      // @param oSession Shell session
 *      // @return Status code
 *     shell_status run(const std::span<const std::string> &vArgs, shell_session &oSession) const override {
 *         // Check there are 0 arguments
 *         if (!vArgs.empty()) {
 *             // Call error printing functon
 *             this->msg_error_param_number(
 *                 oSession.err(), // stderr
 *                 vArgs.size() // Argument number
 *             );
 *             // Return error code 1 (make user code)
 *             return bs::make_user_code(1);
 *         }
 *         // Print "Hello World! on stdout
 *         oSession.out() << "Hello World!";
 *         // Return sucess code
 *         return bs::shell_status::SHELL_SUCCESS;
 *     }
 *
 *      // @brief Print an error if the wrong number of arguments is provided.
 *      // @param oStdErr Stream to print error message.
 *      // @param nArgs Number of provided arguments.
 *     virtual void msg_error_param_number(std::ostream &oStdErr, const std::size_t nArgs) const {
 *         // Print error message
 *         oStdErr << "helloworld: takes 0 parameters, but received " << nArgs << "." << std::endl;
 *         // The user may implement more complex behaviour such as internationalization
 *     }
 * };
 * \endcode
 *
 * Example of adding it to a shell instance:
 *
 * ```hpp
 * auto pShell1 = bs::shell::make_default_shell();
 * pShell1->set_command<command_helloworld>();
 * auto pShell2 = bs::shell::make_default_shell();
 * auto pCommand = std::make_unique<command_helloworld>();
 * pShell2->set_command(std::move(pCommand));
 * ```
 *
 * Example of shell depth check:
 *
 * ```hpp
 * // Increase depth
 * if (!oSession.increase_shell_depth()) {
 *     this->msg_error_max_depth_reached(oSession.err());
 *     return shell_status::SHELL_ERROR_MAX_DEPTH_REACHED;
 * }
 *
 * // Run command here
 *
 * // Decrease depth
 * oSession.decrease_shell_depth();
 * ```
 */